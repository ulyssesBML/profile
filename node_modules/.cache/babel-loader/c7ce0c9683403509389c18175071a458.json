{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/ulysses/Documentos/profile/react-gsap-page-transitions-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventListeners = void 0;\n\nconst Enums_1 = require(\"../Enums\");\n\nconst Constants_1 = require(\"./Constants\");\n\nclass EventListeners {\n  constructor(container) {\n    this.container = container;\n    this.canPush = true;\n\n    this.mouseMoveHandler = e => this.mouseTouchMove(e);\n\n    this.touchStartHandler = e => this.mouseTouchMove(e);\n\n    this.touchMoveHandler = e => this.mouseTouchMove(e);\n\n    this.touchEndHandler = () => this.mouseTouchFinish();\n\n    this.mouseLeaveHandler = () => this.mouseTouchFinish();\n\n    this.touchCancelHandler = () => this.mouseTouchFinish();\n\n    this.touchEndClickHandler = e => this.mouseTouchClick(e);\n\n    this.mouseUpHandler = e => this.mouseTouchClick(e);\n\n    this.mouseDownHandler = () => this.mouseDown();\n\n    this.visibilityChangeHandler = () => this.handleVisibilityChange();\n\n    this.resizeHandler = () => this.handleWindowResize();\n  }\n\n  static manageListener(element, event, handler, add, options) {\n    if (add) {\n      let addOptions = {\n        passive: true\n      };\n\n      if (typeof options === \"boolean\") {\n        addOptions.capture = options;\n      } else if (options !== undefined) {\n        addOptions = options;\n      }\n\n      element.addEventListener(event, handler, addOptions);\n    } else {\n      const removeOptions = options;\n      element.removeEventListener(event, handler, removeOptions);\n    }\n  }\n\n  addListeners() {\n    this.manageListeners(true);\n  }\n\n  removeListeners() {\n    this.manageListeners(false);\n  }\n\n  manageListeners(add) {\n    const container = this.container;\n    const options = container.options;\n    const detectType = options.interactivity.detectsOn;\n    let mouseLeaveEvent = Constants_1.Constants.mouseLeaveEvent;\n\n    if (detectType === Enums_1.InteractivityDetect.window) {\n      container.interactivity.element = window;\n      mouseLeaveEvent = Constants_1.Constants.mouseOutEvent;\n    } else if (detectType === Enums_1.InteractivityDetect.parent && container.canvas.element) {\n      container.interactivity.element = container.canvas.element.parentNode;\n    } else {\n      container.interactivity.element = container.canvas.element;\n    }\n\n    const interactivityEl = container.interactivity.element;\n\n    if (interactivityEl && (options.interactivity.events.onHover.enable || options.interactivity.events.onClick.enable)) {\n      EventListeners.manageListener(interactivityEl, Constants_1.Constants.mouseMoveEvent, this.mouseMoveHandler, add);\n      EventListeners.manageListener(interactivityEl, Constants_1.Constants.touchStartEvent, this.touchStartHandler, add);\n      EventListeners.manageListener(interactivityEl, Constants_1.Constants.touchMoveEvent, this.touchMoveHandler, add);\n\n      if (!options.interactivity.events.onClick.enable) {\n        EventListeners.manageListener(interactivityEl, Constants_1.Constants.touchEndEvent, this.touchEndHandler, add);\n      }\n\n      EventListeners.manageListener(interactivityEl, mouseLeaveEvent, this.mouseLeaveHandler, add);\n      EventListeners.manageListener(interactivityEl, Constants_1.Constants.touchCancelEvent, this.touchCancelHandler, add);\n    }\n\n    if (options.interactivity.events.onClick.enable && interactivityEl) {\n      EventListeners.manageListener(interactivityEl, Constants_1.Constants.touchEndEvent, this.touchEndClickHandler, add);\n      EventListeners.manageListener(interactivityEl, Constants_1.Constants.mouseUpEvent, this.mouseUpHandler, add);\n      EventListeners.manageListener(interactivityEl, Constants_1.Constants.mouseDownEvent, this.mouseDownHandler, add);\n    }\n\n    if (options.interactivity.events.resize) {\n      EventListeners.manageListener(window, Constants_1.Constants.resizeEvent, this.resizeHandler, add);\n    }\n\n    if (document) {\n      EventListeners.manageListener(document, Constants_1.Constants.visibilityChangeEvent, this.visibilityChangeHandler, add, false);\n    }\n  }\n\n  handleWindowResize() {\n    const container = this.container;\n    const options = container.options;\n    const canvas = container.canvas.element;\n\n    if (!canvas) {\n      return;\n    }\n\n    const pxRatio = container.retina.pixelRatio;\n    container.canvas.size.width = canvas.offsetWidth * pxRatio;\n    container.canvas.size.height = canvas.offsetHeight * pxRatio;\n    canvas.width = container.canvas.size.width;\n    canvas.height = container.canvas.size.height;\n\n    if (!options.particles.move.enable) {\n      container.particles.redraw();\n    }\n\n    container.densityAutoParticles();\n\n    for (const _ref of container.plugins) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const plugin = _ref2[1];\n\n      if (plugin.resize !== undefined) {\n        plugin.resize();\n      }\n    }\n  }\n\n  handleVisibilityChange() {\n    const container = this.container;\n    const options = container.options;\n    this.mouseTouchFinish();\n\n    if (!options.pauseOnBlur) {\n      return;\n    }\n\n    if (document === null || document === void 0 ? void 0 : document.hidden) {\n      container.pageHidden = true;\n      container.pause();\n    } else {\n      container.pageHidden = false;\n\n      if (container.getAnimationStatus()) {\n        container.play(true);\n      } else {\n        container.draw();\n      }\n    }\n  }\n\n  mouseDown() {\n    const interactivity = this.container.interactivity;\n\n    if (interactivity) {\n      const mouse = interactivity.mouse;\n      mouse.clicking = true;\n      mouse.downPosition = mouse.position;\n    }\n  }\n\n  mouseTouchMove(e) {\n    var _a, _b, _c;\n\n    const container = this.container;\n    const options = container.options;\n\n    if (((_a = container.interactivity) === null || _a === void 0 ? void 0 : _a.element) === undefined) {\n      return;\n    }\n\n    container.interactivity.mouse.inside = true;\n    let pos;\n    const canvas = container.canvas.element;\n\n    if (e.type.startsWith(\"mouse\")) {\n      this.canPush = true;\n      const mouseEvent = e;\n\n      if (container.interactivity.element === window) {\n        if (canvas) {\n          const clientRect = canvas.getBoundingClientRect();\n          pos = {\n            x: mouseEvent.clientX - clientRect.left,\n            y: mouseEvent.clientY - clientRect.top\n          };\n        }\n      } else if (options.interactivity.detectsOn === Enums_1.InteractivityDetect.parent) {\n        const source = mouseEvent.target;\n        const target = mouseEvent.currentTarget;\n\n        if (source && target) {\n          const sourceRect = source.getBoundingClientRect();\n          const targetRect = target.getBoundingClientRect();\n          pos = {\n            x: mouseEvent.offsetX + sourceRect.left - targetRect.left,\n            y: mouseEvent.offsetY + sourceRect.top - targetRect.top\n          };\n        } else {\n          pos = {\n            x: mouseEvent.offsetX || mouseEvent.clientX,\n            y: mouseEvent.offsetY || mouseEvent.clientY\n          };\n        }\n      } else {\n        if (mouseEvent.target === container.canvas.element) {\n          pos = {\n            x: mouseEvent.offsetX || mouseEvent.clientX,\n            y: mouseEvent.offsetY || mouseEvent.clientY\n          };\n        }\n      }\n    } else {\n      this.canPush = e.type !== \"touchmove\";\n      const touchEvent = e;\n      const lastTouch = touchEvent.touches[touchEvent.touches.length - 1];\n      const canvasRect = canvas === null || canvas === void 0 ? void 0 : canvas.getBoundingClientRect();\n      pos = {\n        x: lastTouch.clientX - ((_b = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.left) !== null && _b !== void 0 ? _b : 0),\n        y: lastTouch.clientY - ((_c = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.top) !== null && _c !== void 0 ? _c : 0)\n      };\n    }\n\n    const pxRatio = container.retina.pixelRatio;\n\n    if (pos) {\n      pos.x *= pxRatio;\n      pos.y *= pxRatio;\n    }\n\n    container.interactivity.mouse.position = pos;\n    container.interactivity.status = Constants_1.Constants.mouseMoveEvent;\n  }\n\n  mouseTouchFinish() {\n    const container = this.container;\n    const interactivity = container.interactivity;\n\n    if (interactivity === undefined) {\n      return;\n    }\n\n    const mouse = interactivity.mouse;\n    delete mouse.position;\n    delete mouse.clickPosition;\n    delete mouse.downPosition;\n    interactivity.status = Constants_1.Constants.mouseLeaveEvent;\n    mouse.inside = false;\n    mouse.clicking = false;\n  }\n\n  mouseTouchClick(e) {\n    const container = this.container;\n    const options = container.options;\n    const mouse = container.interactivity.mouse;\n    mouse.inside = true;\n    let handled = false;\n    const mousePosition = mouse.position;\n\n    if (mousePosition === undefined || !options.interactivity.events.onClick.enable) {\n      return;\n    }\n\n    for (const _ref3 of container.plugins) {\n      var _ref4 = _slicedToArray(_ref3, 2);\n\n      const plugin = _ref4[1];\n\n      if (plugin.clickPositionValid !== undefined) {\n        handled = plugin.clickPositionValid(mousePosition);\n\n        if (handled) {\n          break;\n        }\n      }\n    }\n\n    if (!handled) {\n      this.doMouseTouchClick(e);\n    }\n\n    mouse.clicking = false;\n  }\n\n  doMouseTouchClick(e) {\n    const container = this.container;\n    const options = container.options;\n\n    if (this.canPush) {\n      const mousePos = container.interactivity.mouse.position;\n\n      if (mousePos) {\n        container.interactivity.mouse.clickPosition = {\n          x: mousePos.x,\n          y: mousePos.y\n        };\n      } else {\n        return;\n      }\n\n      container.interactivity.mouse.clickTime = new Date().getTime();\n      const onClick = options.interactivity.events.onClick;\n\n      if (onClick.mode instanceof Array) {\n        for (const mode of onClick.mode) {\n          this.handleClickMode(mode);\n        }\n      } else {\n        this.handleClickMode(onClick.mode);\n      }\n    }\n\n    if (e.type === \"touchend\") {\n      setTimeout(() => this.mouseTouchFinish(), 500);\n    }\n  }\n\n  handleClickMode(mode) {\n    const container = this.container;\n    const options = container.options;\n    const pushNb = options.interactivity.modes.push.quantity;\n    const removeNb = options.interactivity.modes.remove.quantity;\n\n    switch (mode) {\n      case Enums_1.ClickMode.push:\n        {\n          if (pushNb > 0) {\n            if (options.particles.move.enable) {\n              container.particles.push(pushNb, container.interactivity.mouse);\n            } else {\n              if (pushNb === 1) {\n                container.particles.push(pushNb, container.interactivity.mouse);\n              } else if (pushNb > 1) {\n                container.particles.push(pushNb);\n              }\n            }\n          }\n\n          break;\n        }\n\n      case Enums_1.ClickMode.remove:\n        container.particles.removeQuantity(removeNb);\n        break;\n\n      case Enums_1.ClickMode.bubble:\n        container.bubble.clicking = true;\n        break;\n\n      case Enums_1.ClickMode.repulse:\n        container.repulse.clicking = true;\n        container.repulse.count = 0;\n\n        for (const particle of container.repulse.particles) {\n          particle.velocity.horizontal = particle.initialVelocity.horizontal;\n          particle.velocity.vertical = particle.initialVelocity.vertical;\n        }\n\n        container.repulse.particles = [];\n        container.repulse.finish = false;\n        setTimeout(() => {\n          if (!container.destroyed) {\n            container.repulse.clicking = false;\n          }\n        }, options.interactivity.modes.repulse.duration * 1000);\n        break;\n\n      case Enums_1.ClickMode.attract:\n        container.attract.clicking = true;\n        container.attract.count = 0;\n\n        for (const particle of container.attract.particles) {\n          particle.velocity.horizontal = particle.initialVelocity.horizontal;\n          particle.velocity.vertical = particle.initialVelocity.vertical;\n        }\n\n        container.attract.particles = [];\n        container.attract.finish = false;\n        setTimeout(() => {\n          if (!container.destroyed) {\n            container.attract.clicking = false;\n          }\n        }, options.interactivity.modes.attract.duration * 1000);\n        break;\n\n      case Enums_1.ClickMode.pause:\n        if (container.getAnimationStatus()) {\n          container.pause();\n        } else {\n          container.play();\n        }\n\n        break;\n    }\n\n    for (const _ref5 of container.plugins) {\n      var _ref6 = _slicedToArray(_ref5, 2);\n\n      const plugin = _ref6[1];\n\n      if (plugin.handleClickMode) {\n        plugin.handleClickMode(mode);\n      }\n    }\n  }\n\n}\n\nexports.EventListeners = EventListeners;","map":null,"metadata":{},"sourceType":"script"}