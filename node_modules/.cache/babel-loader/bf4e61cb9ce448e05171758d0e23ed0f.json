{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connector = void 0;\n\nconst Utils_1 = require(\"../../../../Utils\");\n\nconst Modes_1 = require(\"../../../../Enums/Modes\");\n\nclass Connector {\n  constructor(container) {\n    this.container = container;\n  }\n\n  isEnabled() {\n    const container = this.container;\n    const mouse = container.interactivity.mouse;\n    const events = container.options.interactivity.events;\n\n    if (!(events.onHover.enable && mouse.position)) {\n      return false;\n    }\n\n    const hoverMode = events.onHover.mode;\n    return Utils_1.Utils.isInArray(Modes_1.HoverMode.connect, hoverMode);\n  }\n\n  reset() {}\n\n  interact() {\n    const container = this.container;\n    const options = container.options;\n\n    if (options.interactivity.events.onHover.enable && container.interactivity.status === \"mousemove\") {\n      const mousePos = container.interactivity.mouse.position;\n\n      if (!mousePos) {\n        return;\n      }\n\n      const distance = Math.abs(container.retina.connectModeRadius);\n      const query = container.particles.quadTree.query(new Utils_1.Circle(mousePos.x, mousePos.y, distance));\n      let i = 0;\n\n      for (const p1 of query) {\n        const pos1 = p1.getPosition();\n\n        for (const p2 of query.slice(i + 1)) {\n          const pos2 = p2.getPosition();\n          const distMax = Math.abs(container.retina.connectModeDistance);\n          const xDiff = Math.abs(pos1.x - pos2.x);\n          const yDiff = Math.abs(pos1.y - pos2.y);\n\n          if (xDiff < distMax && yDiff < distMax) {\n            container.canvas.drawConnectLine(p1, p2);\n          }\n        }\n\n        ++i;\n      }\n    }\n  }\n\n}\n\nexports.Connector = Connector;","map":null,"metadata":{},"sourceType":"script"}