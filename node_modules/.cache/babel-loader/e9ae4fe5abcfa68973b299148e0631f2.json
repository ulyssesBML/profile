{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nconst Enums_1 = require(\"../../Enums\");\n\nclass Updater {\n  constructor(container, particle) {\n    this.container = container;\n    this.particle = particle;\n  }\n\n  update(delta) {\n    if (this.particle.destroyed) {\n      return;\n    }\n\n    this.updateOpacity(delta);\n    this.updateSize(delta);\n    this.updateAngle(delta);\n    this.updateColor(delta);\n    this.updateStrokeColor(delta);\n    this.updateOutMode(delta);\n  }\n\n  updateOpacity(delta) {\n    const particle = this.particle;\n\n    if (particle.particlesOptions.opacity.animation.enable) {\n      switch (particle.opacity.status) {\n        case Enums_1.OpacityAnimationStatus.increasing:\n          if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n          } else {\n            particle.opacity.value += (particle.opacity.velocity || 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.OpacityAnimationStatus.decreasing:\n          if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n          } else {\n            particle.opacity.value -= (particle.opacity.velocity || 0) * delta.factor;\n          }\n\n          break;\n      }\n\n      if (particle.opacity.value < 0) {\n        particle.opacity.value = 0;\n      }\n    }\n  }\n\n  updateSize(delta) {\n    var _a;\n\n    const container = this.container;\n    const particle = this.particle;\n    const sizeOpt = particle.particlesOptions.size;\n    const sizeAnim = sizeOpt.animation;\n\n    if (sizeAnim.enable) {\n      switch (particle.size.status) {\n        case Enums_1.SizeAnimationStatus.increasing:\n          if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n            particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n          } else {\n            particle.size.value += (particle.size.velocity || 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.SizeAnimationStatus.decreasing:\n          if (particle.size.value <= sizeAnim.minimumValue) {\n            particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n          } else {\n            particle.size.value -= (particle.size.velocity || 0) * delta.factor;\n          }\n\n      }\n\n      switch (sizeAnim.destroy) {\n        case Enums_1.DestroyType.max:\n          if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n\n        case Enums_1.DestroyType.min:\n          if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n      }\n\n      if (particle.size.value < 0 && !particle.destroyed) {\n        particle.size.value = 0;\n      }\n    }\n  }\n\n  updateAngle(delta) {\n    const particle = this.particle;\n    const rotate = particle.particlesOptions.rotate;\n    const rotateAnimation = rotate.animation;\n    const speed = rotateAnimation.speed / 360 * delta.factor;\n    const max = 2 * Math.PI;\n\n    if (rotate.path) {\n      particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n    } else {\n      if (rotateAnimation.enable) {\n        switch (particle.rotateDirection) {\n          case Enums_1.RotateDirection.clockwise:\n            particle.angle += speed;\n\n            if (particle.angle > max) {\n              particle.angle -= max;\n            }\n\n            break;\n\n          case Enums_1.RotateDirection.counterClockwise:\n          default:\n            particle.angle -= speed;\n\n            if (particle.angle < 0) {\n              particle.angle += max;\n            }\n\n            break;\n        }\n      }\n    }\n  }\n\n  updateColor(delta) {\n    const particle = this.particle;\n\n    if (particle.color === undefined) {\n      return;\n    }\n\n    if (particle.particlesOptions.color.animation.enable) {\n      particle.color.h += (particle.colorVelocity || 0) * delta.factor;\n\n      if (particle.color.h > 360) {\n        particle.color.h -= 360;\n      }\n    }\n  }\n\n  updateStrokeColor(delta) {\n    const particle = this.particle;\n    const color = particle.stroke.color;\n\n    if (typeof color === \"string\" || color === undefined) {\n      return;\n    }\n\n    if (particle.strokeColor === undefined) {\n      return;\n    }\n\n    if (color.animation.enable) {\n      particle.strokeColor.h += (particle.colorVelocity || 0) * delta.factor;\n\n      if (particle.strokeColor.h > 360) {\n        particle.strokeColor.h -= 360;\n      }\n    }\n  }\n\n  fixOutOfCanvasPosition() {\n    const container = this.container;\n    const particle = this.particle;\n    const wrap = particle.particlesOptions.move.warp;\n    const canvasSize = container.canvas.size;\n    const newPos = {\n      bottom: canvasSize.height + particle.size.value - particle.offset.y,\n      left: -particle.size.value - particle.offset.x,\n      right: canvasSize.width + particle.size.value + particle.offset.x,\n      top: -particle.size.value - particle.offset.y\n    };\n    const sizeValue = particle.size.value;\n    const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n    if (nextBounds.left > canvasSize.width - particle.offset.x) {\n      particle.position.x = newPos.left;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    } else if (nextBounds.right < -particle.offset.x) {\n      particle.position.x = newPos.right;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    }\n\n    if (nextBounds.top > canvasSize.height - particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.top;\n    } else if (nextBounds.bottom < -particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.bottom;\n    }\n  }\n\n  updateOutMode(delta) {\n    const container = this.container;\n    const particle = this.particle;\n\n    switch (particle.particlesOptions.move.outMode) {\n      case Enums_1.OutMode.bounce:\n      case Enums_1.OutMode.bounceVertical:\n      case Enums_1.OutMode.bounceHorizontal:\n        this.updateBounce(delta);\n        break;\n\n      case Enums_1.OutMode.destroy:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n          particle.destroy();\n          container.particles.remove(particle);\n          return;\n        }\n\n        break;\n\n      case Enums_1.OutMode.out:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n          this.fixOutOfCanvasPosition();\n        }\n\n    }\n  }\n\n  updateBounce(delta) {\n    const container = this.container;\n    const particle = this.particle;\n    let handled = false;\n\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleBounce !== undefined) {\n        handled = plugin.particleBounce(particle, delta);\n      }\n\n      if (handled) {\n        break;\n      }\n    }\n\n    if (handled) {\n      return;\n    }\n\n    const outMode = particle.particlesOptions.move.outMode,\n          pos = particle.getPosition(),\n          offset = particle.offset,\n          size = particle.size.value,\n          bounds = Utils_1.Utils.calculateBounds(pos, size),\n          canvasSize = container.canvas.size;\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n      const velocity = particle.velocity.horizontal;\n\n      if (bounds.right >= canvasSize.width && velocity > 0 || bounds.left <= 0 && velocity < 0) {\n        particle.velocity.horizontal *= -1;\n      }\n\n      const minPos = offset.x + size;\n\n      if (bounds.right >= canvasSize.width) {\n        particle.position.x = canvasSize.width - minPos;\n      } else if (bounds.left <= 0) {\n        particle.position.x = minPos;\n      }\n    }\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n      const velocity = particle.velocity.vertical;\n\n      if (bounds.bottom >= container.canvas.size.height && velocity > 0 || bounds.top <= 0 && velocity < 0) {\n        particle.velocity.vertical *= -1;\n      }\n\n      const minPos = offset.y + size;\n\n      if (bounds.bottom >= canvasSize.height) {\n        particle.position.y = canvasSize.height - minPos;\n      } else if (bounds.top <= 0) {\n        particle.position.y = minPos;\n      }\n    }\n  }\n\n}\n\nexports.Updater = Updater;","map":null,"metadata":{},"sourceType":"script"}