{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ColorUtils = void 0;\n\nconst Utils_1 = require(\"./Utils\");\n\nconst Constants_1 = require(\"./Constants\");\n\nclass ColorUtils {\n  static colorToRgb(input) {\n    var _a, _b;\n\n    if (input === undefined) {\n      return;\n    }\n\n    const color = typeof input === \"string\" ? {\n      value: input\n    } : input;\n    let res;\n\n    if (typeof color.value === \"string\") {\n      if (color.value === Constants_1.Constants.randomColorValue) {\n        res = this.getRandomRgbColor();\n      } else {\n        res = ColorUtils.stringToRgb(color.value);\n      }\n    } else {\n      if (color.value instanceof Array) {\n        const colorSelected = Utils_1.Utils.itemFromArray(color.value);\n        res = ColorUtils.colorToRgb({\n          value: colorSelected\n        });\n      } else {\n        const colorValue = color.value;\n        const rgbColor = (_a = colorValue.rgb) !== null && _a !== void 0 ? _a : color.value;\n\n        if (rgbColor.r !== undefined) {\n          res = rgbColor;\n        } else {\n          const hslColor = (_b = colorValue.hsl) !== null && _b !== void 0 ? _b : color.value;\n\n          if (hslColor.h !== undefined) {\n            res = ColorUtils.hslToRgb(hslColor);\n          }\n        }\n      }\n    }\n\n    return res;\n  }\n\n  static colorToHsl(color) {\n    const rgb = this.colorToRgb(color);\n    return rgb !== undefined ? this.rgbToHsl(rgb) : rgb;\n  }\n\n  static rgbToHsl(color) {\n    const r1 = color.r / 255;\n    const g1 = color.g / 255;\n    const b1 = color.b / 255;\n    const max = Math.max(r1, g1, b1);\n    const min = Math.min(r1, g1, b1);\n    const res = {\n      h: 0,\n      l: (max + min) / 2,\n      s: 0\n    };\n\n    if (max != min) {\n      res.s = res.l < 0.5 ? (max - min) / (max + min) : (max - min) / (2.0 - max - min);\n      res.h = r1 === max ? (g1 - b1) / (max - min) : res.h = g1 === max ? 2.0 + (b1 - r1) / (max - min) : 4.0 + (r1 - g1) / (max - min);\n    }\n\n    res.l *= 100;\n    res.s *= 100;\n    res.h *= 60;\n\n    if (res.h < 0) {\n      res.h += 360;\n    }\n\n    return res;\n  }\n\n  static stringToAlpha(input) {\n    var _a;\n\n    return (_a = ColorUtils.stringToRgba(input)) === null || _a === void 0 ? void 0 : _a.a;\n  }\n\n  static stringToRgb(input) {\n    return ColorUtils.stringToRgba(input);\n  }\n\n  static hslToRgb(hsl) {\n    const result = {\n      b: 0,\n      g: 0,\n      r: 0\n    };\n    const hslPercent = {\n      h: hsl.h / 360,\n      l: hsl.l / 100,\n      s: hsl.s / 100\n    };\n\n    if (hslPercent.s === 0) {\n      result.b = hslPercent.l;\n      result.g = hslPercent.l;\n      result.r = hslPercent.l;\n    } else {\n      const q = hslPercent.l < 0.5 ? hslPercent.l * (1 + hslPercent.s) : hslPercent.l + hslPercent.s - hslPercent.l * hslPercent.s;\n      const p = 2 * hslPercent.l - q;\n      result.r = ColorUtils.hue2rgb(p, q, hslPercent.h + 1 / 3);\n      result.g = ColorUtils.hue2rgb(p, q, hslPercent.h);\n      result.b = ColorUtils.hue2rgb(p, q, hslPercent.h - 1 / 3);\n    }\n\n    result.r = Math.floor(result.r * 255);\n    result.g = Math.floor(result.g * 255);\n    result.b = Math.floor(result.b * 255);\n    return result;\n  }\n\n  static hslaToRgba(hsla) {\n    const rgbResult = ColorUtils.hslToRgb(hsla);\n    return {\n      a: hsla.a,\n      b: rgbResult.b,\n      g: rgbResult.g,\n      r: rgbResult.r\n    };\n  }\n\n  static getRandomRgbColor(min) {\n    const fixedMin = min !== null && min !== void 0 ? min : 0;\n    return {\n      b: Math.floor(Utils_1.Utils.randomInRange(fixedMin, 256)),\n      g: Math.floor(Utils_1.Utils.randomInRange(fixedMin, 256)),\n      r: Math.floor(Utils_1.Utils.randomInRange(fixedMin, 256))\n    };\n  }\n\n  static getStyleFromRgb(color, opacity) {\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${opacity !== null && opacity !== void 0 ? opacity : 1})`;\n  }\n\n  static getStyleFromHsl(color, opacity) {\n    return `hsla(${color.h}, ${color.s}%, ${color.l}%, ${opacity !== null && opacity !== void 0 ? opacity : 1})`;\n  }\n\n  static mix(color1, color2, size1, size2) {\n    let rgb1 = color1;\n    let rgb2 = color2;\n\n    if (rgb1.r === undefined) {\n      rgb1 = this.hslToRgb(color1);\n    }\n\n    if (rgb2.r === undefined) {\n      rgb2 = this.hslToRgb(color2);\n    }\n\n    return {\n      b: Utils_1.Utils.mix(rgb1.b, rgb2.b, size1, size2),\n      g: Utils_1.Utils.mix(rgb1.g, rgb2.g, size1, size2),\n      r: Utils_1.Utils.mix(rgb1.r, rgb2.r, size1, size2)\n    };\n  }\n\n  static replaceColorSvg(image, color, opacity) {\n    if (!image.svgData) {\n      return \"\";\n    }\n\n    const svgXml = image.svgData;\n    const rgbHex = /#([0-9A-F]{3,6})/gi;\n    return svgXml.replace(rgbHex, () => ColorUtils.getStyleFromHsl(color, opacity));\n  }\n\n  static hue2rgb(p, q, t) {\n    let tCalc = t;\n\n    if (tCalc < 0) {\n      tCalc += 1;\n    }\n\n    if (tCalc > 1) {\n      tCalc -= 1;\n    }\n\n    if (tCalc < 1 / 6) {\n      return p + (q - p) * 6 * tCalc;\n    }\n\n    if (tCalc < 1 / 2) {\n      return q;\n    }\n\n    if (tCalc < 2 / 3) {\n      return p + (q - p) * (2 / 3 - tCalc) * 6;\n    }\n\n    return p;\n  }\n\n  static stringToRgba(input) {\n    if (input.startsWith(\"rgb\")) {\n      const regex = /rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([\\d.]+)\\s*)?\\)/i;\n      const result = regex.exec(input);\n      return result ? {\n        a: result.length > 4 ? parseFloat(result[5]) : 1,\n        b: parseInt(result[3], 10),\n        g: parseInt(result[2], 10),\n        r: parseInt(result[1], 10)\n      } : undefined;\n    } else if (input.startsWith(\"hsl\")) {\n      const regex = /hsla?\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(,\\s*([\\d.]+)\\s*)?\\)/i;\n      const result = regex.exec(input);\n      return result ? ColorUtils.hslaToRgba({\n        a: result.length > 4 ? parseFloat(result[5]) : 1,\n        h: parseInt(result[1], 10),\n        l: parseInt(result[3], 10),\n        s: parseInt(result[2], 10)\n      }) : undefined;\n    } else {\n      const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?$/i;\n      const hexFixed = input.replace(shorthandRegex, (_m, r, g, b, a) => {\n        return r + r + g + g + b + b + (a !== undefined ? a + a : \"\");\n      });\n      const regex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i;\n      const result = regex.exec(hexFixed);\n      return result ? {\n        a: result[4] !== undefined ? parseInt(result[4], 16) / 0xff : 1,\n        b: parseInt(result[3], 16),\n        g: parseInt(result[2], 16),\n        r: parseInt(result[1], 16)\n      } : undefined;\n    }\n  }\n\n}\n\nexports.ColorUtils = ColorUtils;","map":null,"metadata":{},"sourceType":"script"}